# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:31:31+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyQuery, BaseSecurity
from fastapi import Header, Query
from pydantic import conint

from models import (
    AndCategory,
    AndHasLargeThumbnailUrl,
    AndHasLatLng,
    AndUsage,
    Direction,
    Facets,
    Format,
    Record,
    Sort,
)
from models.Records import FieldFormatGetResponse, FieldFormatGetResponseModel
from models.Records_recordId_ import FieldFormatGetResponse
from models.Records_recordId_MoreLikeThis import (
    FieldFormatGetResponse,
    FieldFormatGetResponseModel,
)

app = MCPProxy(
    contact={'email': 'develop@digitalnz.org', 'name': 'DigitalNZ'},
    description="OpenAPI specification of DigitalNZ's Record API.  \nFor more information about the API see [digitalnz.org/developers](https://digitalnz.org/developers).  \nTo learn more about the metadata/fields used in the API see the [Metadata Dictionary](https://docs.google.com/document/pub?id=1Z3I_ckQWjnQQ4SzpORbClcIXUheO-Jd4jt-oZFuMcoQ).  \nTo get a sense of what content is available via the API take a look at the search feature on the [DigitalNZ website](https://digitalnz.org/records?text=all%20sorts&tab=Images).  \nThe [terms of use](https://digitalnz.org/about/terms-of-use/developer-api-terms-of-use) specify how developers can use the DigitalNZ API.\n",
    title='DigitalNZ API',
    version='3',
    servers=[{'description': 'Production API', 'url': 'https://api.digitalnz.org'}],
)


@app.get(
    '/records.{format}',
    description=""" This is the main search endpoint allowing queries against the records database. """,
    tags=['metadata_query_operations'],
    security=[
        APIKeyQuery(name="api_key"),
    ],
)
def get_records__format(
    format: Format,
    authentication__token: Optional[str] = Header(None, alias='Authentication-Token'),
    text: Optional[str] = None,
    and_category___: Optional[AndCategory] = Query(None, alias='and[category][]'),
    and_content_partner___: Optional[str] = Query(None, alias='and[content_partner][]'),
    and_primary_collection___: Optional[str] = Query(
        None, alias='and[primary_collection][]'
    ),
    and_collection___: Optional[str] = Query(None, alias='and[collection][]'),
    and_usage___: Optional[AndUsage] = Query(None, alias='and[usage][]'),
    and_subject___: Optional[str] = Query(None, alias='and[subject][]'),
    and_dc_type___: Optional[str] = Query(None, alias='and[dc_type][]'),
    and_format___: Optional[str] = Query(None, alias='and[format][]'),
    and_placename___: Optional[str] = Query(None, alias='and[placename][]'),
    and_creator___: Optional[str] = Query(None, alias='and[creator][]'),
    and_title___: Optional[str] = Query(None, alias='and[title][]'),
    and_date_: Optional[str] = Query(None, alias='and[date]'),
    and_year_: Optional[str] = Query(None, alias='and[year]'),
    and_decade_: Optional[str] = Query(None, alias='and[decade]'),
    and_century_: Optional[str] = Query(None, alias='and[century]'),
    without__filter_field__: Optional[str] = Query(
        None, alias='without[{filter_field}]'
    ),
    and_or___filter_field____: Optional[str] = Query(
        None, alias='and[or][{filter_field}][]'
    ),
    and_is_commercial_use_: Optional[bool] = Query(
        None, alias='and[is_commercial_use]'
    ),
    and_has_large_thumbnail_url_: Optional[AndHasLargeThumbnailUrl] = Query(
        None, alias='and[has_large_thumbnail_url]'
    ),
    and_has_lat_lng_: Optional[AndHasLatLng] = Query(None, alias='and[has_lat_lng]'),
    geo_bbox: Optional[str] = None,
    fields: Optional[str] = None,
    sort: Optional[Sort] = None,
    direction: Optional[Direction] = 'asc',
    page: Optional[conint(ge=1)] = 1,
    per_page: Optional[conint(ge=0, le=100)] = 20,
    facets: Optional[Facets] = None,
    facets_page: Optional[conint(ge=1)] = None,
    facets_per_page: Optional[conint(le=350)] = 10,
    exclude_filters_from_facets: Optional[bool] = False,
):
    """
    Run queries against DigitalNZ metadata search service.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/records/{record_id}.{format}',
    description=""" If you know its `record_id` you can use this endpoint to view all metadata associated with that specific record.
 """,
    tags=['metadata_query_operations', 'individual_record_handling'],
    security=[
        APIKeyQuery(name="api_key"),
    ],
)
def get_records__record_id__format(
    record_id: int,
    format: Format = ...,
    authentication__token: Optional[str] = Header(None, alias='Authentication-Token'),
    fields: Optional[str] = None,
):
    """
    View metadata associated with a single record.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/records/{record_id}/more_like_this.{format}',
    description=""" This feature returns a set of search results that are similar (ie have similar metadata) to a specific record.
 """,
    tags=['metadata_query_operations', 'individual_record_handling'],
    security=[
        APIKeyQuery(name="api_key"),
    ],
)
def get_records__record_id_more_like_this__format(
    record_id: int,
    format: Format = ...,
    authentication__token: Optional[str] = Header(None, alias='Authentication-Token'),
    fields: Optional[str] = None,
    mlt_fields: Optional[str] = None,
    filtering: Optional[str] = None,
):
    """
    The "More Like This" call returns similar records to the specified ID.

    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
